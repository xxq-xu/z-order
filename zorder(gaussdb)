Datum get_partitionid(PG_FUNCTION_ARGS)
{
    int32 result = -1;

    result = (int32)get_partitionid_internal(fcinfo);

    if (result < 0)
    {
        ereport(ERROR,
                (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),
                 errmsg("result out of range (< 0)")));
    }
    PG_RETURN_INT32(result);
}

static int get_partitionid_internal(FunctionCallInfo fcinfo)
{
    ArrayType *array = PG_GETARG_ARRAYTYPE_P(0);
    Datum elt1;
    Oid element_type_value = get_fn_expr_argtype(fcinfo->flinfo, 1);
    Oid element_type_array = ARR_ELEMTYPE(array);
    int ndims = ARR_NDIM(array);
    int *dims = ARR_DIMS(array);
    int nitems = ArrayGetNItems(ndims, dims);
    int typlen;
    bool typbyval = false;
    char typalign;
    Oid collation = PG_GET_COLLATION();
    char *ptr = NULL;
    TypeCacheEntry *typentry = NULL;
    FunctionCallInfoData locfcinfo;

    // if value is not null, get value from arg (value is anyelement, i.e. polymorphic)
    if (PG_ARGISNULL(0) || PG_ARGISNULL(1))
        ereport(ERROR,
                (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
                 errmsg("arg cannot be null")));
    else
        elt1 = PG_GETARG_DATUM(1);
    // types need to be the same
    if (element_type_array != element_type_value)
    {
        ereport(ERROR,
                (errcode(ERRCODE_DATATYPE_MISMATCH),
                 errmsg("cannot compare values of different element types for binary search")));
    }

    // prepare for the cmp operator
    /*
     * We arrange to look up the comparison function only once per series of
     * calls, assuming the element type doesn't change underneath us. The
     * typcache is used so that we have no memory leakage when being used as
     * an index support function.
     */
    typentry = (TypeCacheEntry *)fcinfo->flinfo->fn_extra;
    if (typentry == NULL ||
        typentry->type_id != element_type_array)
    {
        typentry = lookup_type_cache(element_type_array,
                                     TYPECACHE_CMP_PROC_FINFO);
        if (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))
            ereport(ERROR,
                    (errcode(ERRCODE_UNDEFINED_FUNCTION),
                     errmsg("could not identify a comparison function for type %s",
                            format_type_be(element_type_array))));
        fcinfo->flinfo->fn_extra = (void *)typentry;
    }
    // Varlena typlen is -1
    typlen = typentry->typlen;
    typbyval = typentry->typbyval;
    typalign = typentry->typalign;

    /*
     * apply the operator to each pair of array elements.
     */
    InitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,
                             collation, NULL, NULL);
    // (array should have no null value)
    int result = -1;
    // binary search for Fixed-Length Type
    if (typlen > 0)
    {
        int left = 0;
        int right = nitems - 1;
        while (left <= right)
        {
            Datum elt0;
            int mid = left + (right - left) / 2;
            int32 cmpresult;

            // fetching array values at mid index
            ptr = ARR_DATA_PTR(array);
            if (mid > 0)
            {
                ptr = att_addlength_pointer(ptr, typlen * mid, ptr);
                ptr = (char *)att_align_nominal(ptr, typalign);
            }
            elt0 = fetch_att(ptr, typbyval, typlen);

            /* Compare the pair of elements */
            locfcinfo.arg[0] = elt0;
            locfcinfo.arg[1] = elt1;
            locfcinfo.argnull[0] = false;
            locfcinfo.argnull[1] = false;
            locfcinfo.isnull = false;
            cmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));

            if (cmpresult == 0)
            {
                /* equal */
                return mid;
            }
            else if (cmpresult < 0)
            {
                /* array cur_val < arg_1 val, then search backward */
                left = mid + 1;
            }
            else
            {
                /* array cur_val > arg_1 val, then search forward */
                result = mid;
                right = mid - 1;
            }
        }
    }
    // sequential search for Variable-Length Type
    else
    {
        ptr = ARR_DATA_PTR(array);
        Datum elt0;
        for (int i = 0; i < nitems; i++)
        {
            elt0 = fetch_att(ptr, typbyval, typlen);
            ptr = att_addlength_pointer(ptr, typlen, ptr);
            ptr = (char *)att_align_nominal(ptr, typalign);
            int32 cmpresult;
            locfcinfo.arg[0] = elt0;
            locfcinfo.arg[1] = elt1;
            locfcinfo.argnull[0] = false;
            locfcinfo.argnull[1] = false;
            locfcinfo.isnull = false;
            cmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));
            if (cmpresult >= 0)
            {
                result = i;
                break;
            }
        }
    }

    /* array is not null, so when result is -1, the elt1 > array[-1] */
    if (result == -1)
    {
        return nitems;
    }
    return result;
}
