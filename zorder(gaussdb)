Datum get_partitionid(PG_FUNCTION_ARGS)
{
    int32 result = -1;

    result = (int32)get_partitionid_internal(fcinfo);

    if (result < 0)
    {
        ereport(ERROR,
                (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),
                 errmsg("result out of range (< 0)")));
    }
    PG_RETURN_INT32(result);
}

static int get_partitionid_internal(FunctionCallInfo fcinfo)
{
    ArrayType *array = PG_GETARG_ARRAYTYPE_P(0);
    Datum elt1;
    Oid element_type_value = get_fn_expr_argtype(fcinfo->flinfo, 1);
    Oid element_type_array = ARR_ELEMTYPE(array);
    int ndims = ARR_NDIM(array);
    int *dims = ARR_DIMS(array);
    int nitems = ArrayGetNItems(ndims, dims);
    int typlen;
    bool typbyval = false;
    char typalign;
    Oid collation = PG_GET_COLLATION();
    char *ptr = NULL;
    TypeCacheEntry *typentry = NULL;
    FunctionCallInfoData locfcinfo;

    // if value is not null, get value from arg (value is anyelement, i.e. polymorphic)
    if (PG_ARGISNULL(0) || PG_ARGISNULL(1))
        ereport(ERROR,
                (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
                 errmsg("arg cannot be null")));
    else
        elt1 = PG_GETARG_DATUM(1);
    // types need to be the same
    if (element_type_array != element_type_value)
    {
        ereport(ERROR,
                (errcode(ERRCODE_DATATYPE_MISMATCH),
                 errmsg("cannot compare values of different element types for binary search")));
    }

    // prepare for the cmp operator
    /*
     * We arrange to look up the comparison function only once per series of
     * calls, assuming the element type doesn't change underneath us. The
     * typcache is used so that we have no memory leakage when being used as
     * an index support function.
     */
    typentry = (TypeCacheEntry *)fcinfo->flinfo->fn_extra;
    if (typentry == NULL ||
        typentry->type_id != element_type_array)
    {
        typentry = lookup_type_cache(element_type_array,
                                     TYPECACHE_CMP_PROC_FINFO);
        if (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))
            ereport(ERROR,
                    (errcode(ERRCODE_UNDEFINED_FUNCTION),
                     errmsg("could not identify a comparison function for type %s",
                            format_type_be(element_type_array))));
        fcinfo->flinfo->fn_extra = (void *)typentry;
    }
    // Varlena typlen is -1
    typlen = typentry->typlen;
    typbyval = typentry->typbyval;
    typalign = typentry->typalign;

    /*
     * apply the operator to each pair of array elements.
     */
    InitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,
                             collation, NULL, NULL);
    // (array should have no null value)
    int result = -1;
    // binary search for Fixed-Length Type
    if (typlen > 0)
    {
        int left = 0;
        int right = nitems - 1;
        while (left <= right)
        {
            Datum elt0;
            int mid = left + (right - left) / 2;
            int32 cmpresult;

            // fetching array values at mid index
            ptr = ARR_DATA_PTR(array);
            if (mid > 0)
            {
                ptr = att_addlength_pointer(ptr, typlen * mid, ptr);
                ptr = (char *)att_align_nominal(ptr, typalign);
            }
            elt0 = fetch_att(ptr, typbyval, typlen);

            /* Compare the pair of elements */
            locfcinfo.arg[0] = elt0;
            locfcinfo.arg[1] = elt1;
            locfcinfo.argnull[0] = false;
            locfcinfo.argnull[1] = false;
            locfcinfo.isnull = false;
            cmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));

            if (cmpresult == 0)
            {
                /* equal */
                return mid;
            }
            else if (cmpresult < 0)
            {
                /* array cur_val < arg_1 val, then search backward */
                left = mid + 1;
            }
            else
            {
                /* array cur_val > arg_1 val, then search forward */
                result = mid;
                right = mid - 1;
            }
        }
    }
    // sequential search for Variable-Length Type
    else
    {
        ptr = ARR_DATA_PTR(array);
        Datum elt0;
        for (int i = 0; i < nitems; i++)
        {
            elt0 = fetch_att(ptr, typbyval, typlen);
            ptr = att_addlength_pointer(ptr, typlen, ptr);
            ptr = (char *)att_align_nominal(ptr, typalign);
            int32 cmpresult;
            locfcinfo.arg[0] = elt0;
            locfcinfo.arg[1] = elt1;
            locfcinfo.argnull[0] = false;
            locfcinfo.argnull[1] = false;
            locfcinfo.isnull = false;
            cmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));
            if (cmpresult >= 0)
            {
                result = i;
                break;
            }
        }
    }

    /* array is not null, so when result is -1, the elt1 > array[-1] */
    if (result == -1)
    {
        return nitems;
    }
    return result;
}






include "postgres.h"

#include "utils/builtins.h"
#include "utils/zorder.h"
#include "utils/datum.h"
#include "utils/typcache.h"
#include "catalog/pg_type.h"

static int get_partitionid_internal(FunctionCallInfo fcinfo);

Datum get_bounds_addr(PG_FUNCTION_ARGS) {
    if (PG_ARGISNULL(0))
        ereport(ERROR,
                (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
                 errmsg("array arg cannot be null")));

    ArrayType *array = PG_GETARG_ARRAYTYPE_P(0);
    ArrayType *result = NULL;
    Oid element_type = ARR_ELEMTYPE(array);
    int ndims = ARR_NDIM(array);
    int *dims = ARR_DIMS(array);
    int nitems = ArrayGetNItems(ndims, dims);
    int typlen;
    // bool typbyval = false;
    char typalign;
    TypeCacheEntry *typentry = NULL;

    typentry = (TypeCacheEntry *)fcinfo->flinfo->fn_extra;
    if (typentry == NULL ||
        typentry->type_id != element_type)
    {
        typentry = lookup_type_cache(element_type,
                                     TYPECACHE_CMP_PROC_FINFO);
        fcinfo->flinfo->fn_extra = (void *)typentry;
    }
    // Varlena typlen is -1
    typlen = typentry->typlen;
    // typbyval = typentry->typbyval;
    typalign = typentry->typalign;

    // prepare for result array
    int nbytes = sizeof(int) * nitems;
    nbytes += ARR_OVERHEAD_NONULLS(ndims);
    result = (ArrayType *) palloc0(nbytes);
    SET_VARSIZE(result, nbytes);
    result->ndim = ndims;
	result->dataoffset = 0;
	result->elemtype = element_type;

    // if typlen == -1
    char *head_ptr = ARR_DATA_PTR(array);
    char *ptr = ARR_DATA_PTR(array);
    int *data = ARR_DIMS(result);
    for (int i=0; i<nitems; i++) {
        data[i] = ptr - head_ptr;
        ptr = att_addlength_pointer(ptr, typlen, ptr);
        ptr = (char *)att_align_nominal(ptr, typalign);
    }
    PG_RETURN_ARRAYTYPE_P(result);
}

/*
 * get_partitionid via binary search O(logn) or sequential search O(n)
 *      For Fixed-Length Type, we can use binary search directly
 *      For Variable-Length Type, like numeric text char*, which typlen == -1 or -2,
 *          we should use sequential search. so it's best not to use the Variable-Length Type in zorder
 *
 * TODO: For variable length type, we can define a special range_bounds_array which
 *           has accumulated position index, so we can use binary search instead of seq search.
 *       Accumulated position index should initialize in reservoir sampling finalfunc.
 *       range_bounds like this : [[bounds...], [store index...]]
 */
Datum get_partitionid(PG_FUNCTION_ARGS)
{
    int32 result = -1;

    result = (int32)get_partitionid_internal(fcinfo);

    if (result < 0)
    {
        ereport(ERROR,
                (errcode(ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE),
                 errmsg("result out of range (< 0)")));
    }
    PG_RETURN_INT32(result);
}

static int get_partitionid_internal(FunctionCallInfo fcinfo)
{
    if (PG_ARGISNULL(0) || PG_ARGISNULL(2))
        ereport(ERROR,
                (errcode(ERRCODE_NULL_VALUE_NOT_ALLOWED),
                 errmsg("array arg cannot be null")));
    ArrayType *array = PG_GETARG_ARRAYTYPE_P(0);
    ArrayType *array_addr = PG_GETARG_ARRAYTYPE_P(2);
    Datum elt1;
    Oid element_type_value = get_fn_expr_argtype(fcinfo->flinfo, 1);
    Oid element_type_array = ARR_ELEMTYPE(array);
    int ndims = ARR_NDIM(array);
    int *dims = ARR_DIMS(array);
    int nitems = ArrayGetNItems(ndims, dims);
    int typlen;
    bool typbyval = false;
    char typalign;
    Oid collation = PG_GET_COLLATION();
    char *ptr = NULL;
    TypeCacheEntry *typentry = NULL;
    FunctionCallInfoData locfcinfo;

    // if value is not null, get value from arg (value is anyelement, i.e. polymorphic)
    if (PG_ARGISNULL(1))
        return nitems+1;  // return the upper bound + 1 for null
    else
        elt1 = PG_GETARG_DATUM(1);
    // types need to be the same
    if (element_type_array != element_type_value)
    {
        ereport(ERROR,
                (errcode(ERRCODE_DATATYPE_MISMATCH),
                 errmsg("cannot compare values of different element types for binary search")));
    }

    // prepare for the cmp operator
    /*
     * We arrange to look up the comparison function only once per series of
     * calls, assuming the element type doesn't change underneath us. The
     * typcache is used so that we have no memory leakage when being used as
     * an index support function.
     */
    typentry = (TypeCacheEntry *)fcinfo->flinfo->fn_extra;
    if (typentry == NULL ||
        typentry->type_id != element_type_array)
    {
        typentry = lookup_type_cache(element_type_array,
                                     TYPECACHE_CMP_PROC_FINFO);
        if (!OidIsValid(typentry->cmp_proc_finfo.fn_oid))
            ereport(ERROR,
                    (errcode(ERRCODE_UNDEFINED_FUNCTION),
                     errmsg("could not identify a comparison function for type %s",
                            format_type_be(element_type_array))));
        fcinfo->flinfo->fn_extra = (void *)typentry;
    }
    // Varlena typlen is -1
    typlen = typentry->typlen;
    typbyval = typentry->typbyval;
    typalign = typentry->typalign;

    /*
     * apply the operator to each pair of array elements.
     */
    InitFunctionCallInfoData(locfcinfo, &typentry->cmp_proc_finfo, 2,
                             collation, NULL, NULL);
    // (array should have no null value)
    int result = -1;
    // binary search for Fixed-Length Type
    if (typlen > 0)
    {
        int left = 0;
        int right = nitems - 1;
        while (left <= right)
        {
            Datum elt0;
            int mid = left + (right - left) / 2;
            int32 cmpresult;

            // fetching array values at mid index
            ptr = ARR_DATA_PTR(array);
            if (mid > 0)
            {
                ptr = att_addlength_pointer(ptr, typlen * mid, ptr);
                ptr = (char *)att_align_nominal(ptr, typalign);
            }
            elt0 = fetch_att(ptr, typbyval, typlen);

            /* Compare the pair of elements */
            locfcinfo.arg[0] = elt0;
            locfcinfo.arg[1] = elt1;
            locfcinfo.argnull[0] = false;
            locfcinfo.argnull[1] = false;
            locfcinfo.isnull = false;
            cmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));

            if (cmpresult == 0)
            {
                /* equal */
                return mid;
            }
            else if (cmpresult < 0)
            {
                /* array cur_val < arg_1 val, then search backward */
                left = mid + 1;
            }
            else
            {
                /* array cur_val > arg_1 val, then search forward */
                result = mid;
                right = mid - 1;
            }
        }
    }
    // binary search for Variable-Length Type
    else
    {
        Oid addr_element_type = ARR_ELEMTYPE(array_addr);
        if (addr_element_type != INT4OID) {
            ereport(ERROR,
                    (errcode(ERRCODE_DATATYPE_MISMATCH),
                    errmsg("type of arg-3 should be _int4")));
        }
        typentry = (TypeCacheEntry *)fcinfo->flinfo->fn_extra;
        if (typentry == NULL ||
            typentry->type_id != addr_element_type)
        {
            typentry = lookup_type_cache(addr_element_type,
                                        TYPECACHE_CMP_PROC_FINFO);
            fcinfo->flinfo->fn_extra = (void *)typentry;
        }
        // Varlena typlen is -1
        int addr_typlen;
        bool addr_typbyval = false;
        char addr_typalign;
        addr_typlen = typentry->typlen;
        addr_typbyval = typentry->typbyval;
        addr_typalign = typentry->typalign;
        int left = 0;
        int right = nitems - 1;
        char *addr_ptr = NULL;
        while (left <= right)
        {
            Datum elt0;
            int mid = left + (right - left) / 2;
            int32 cmpresult;

            // fetching array values at mid index
            ptr = ARR_DATA_PTR(array);
            addr_ptr = ARR_DATA_PTR(array_addr);
            if (mid > 0)
            {
                addr_ptr = att_addlength_pointer(ptr, addr_typlen * mid, ptr);
                addr_ptr = (char *)att_align_nominal(ptr, addr_typalign);
                ptr += DatumGetInt32(fetch_att(addr_ptr, addr_typbyval, addr_typlen));
            }
            elt0 = fetch_att(ptr, typbyval, typlen);

            /* Compare the pair of elements */
            locfcinfo.arg[0] = elt0;
            locfcinfo.arg[1] = elt1;
            locfcinfo.argnull[0] = false;
            locfcinfo.argnull[1] = false;
            locfcinfo.isnull = false;
            cmpresult = DatumGetInt32(FunctionCallInvoke(&locfcinfo));

            if (cmpresult == 0)
            {
                /* equal */
                return mid;
            }
            else if (cmpresult < 0)
            {
                /* array cur_val < arg_1 val, then search backward */
                left = mid + 1;
            }
            else
            {
                /* array cur_val > arg_1 val, then search forward */
                result = mid;
                right = mid - 1;
            }
        }
    }

    /* array is not null, so when result is -1, the elt1 > array[-1] */
    if (result == -1)
    {
        return nitems;
    }
    return result;
}


#ifndef ZORDER_H
#define ZORDER_H

#include "array.h"

/* zorder functions */
extern Datum get_bounds_addr(PG_FUNCTION_ARGS);
extern Datum get_partitionid(PG_FUNCTION_ARGS);

#endif /* ZORDER_H */

